---
id: redux
title: 'My Mental Model: Redux'
date: '2019-06-29T02:18:19.900Z'
description: My mental model of Redux
---

import { Figure } from '../../../src/components/CaptionedFigure'
import {
  FixedAspectRatioBox,
  CappedWidthBox,
} from '../../../src/components/FixedAspectRatioBox'
import { Counter } from './Counter'

<Figure>
  <CappedWidthBox maxWidth={300}>
    <FixedAspectRatioBox aspectRatio={2383 / 2500}>
      <img
        src="https://res.cloudinary.com/tripphamm/image/upload/v1577720577/logos/redux-logo_d1kpyb.svg"
        alt="Redux logo"
      />
    </FixedAspectRatioBox>
  </CappedWidthBox>
</Figure>

## My Mental Model Series

_This article is part of the My Mental Model series which seeks to capture my understanding of the programming concepts that I use on a regular basis in a comprehensive way. The goal is for readers to have all of the info that they need in order to reach and to surpass my own understanding of each concept._

## Introduction

[Redux](https://github.com/reduxjs/redux) is a popular JavaScript library which is commonly paired together with UI frameworks (like Angular or React) in order to develop complex applications that are scalable and easy to maintain. In this installment of _My Mental Model_ I'll introduce the core concepts of Redux and then we'll build a minimal app with plain HTML/CSS/JS in order to illustrate those concepts in isolation before exploring integrations with UI frameworks (which we'll do in another post).

## Redux

Redux is a _state management_ library which means that it deals with the _data behind your UI_ (more on this later) rather than dealing with your UI itself. In fact, **Redux is entirely unopinionated about your UI** meaning that it can be used alongside _any_ UI framework (React, Angular, Vue, or even plain old HTML/CSS/JS)! This is sometimes surprising to folks who have only seen Redux used alongside React, but we'll see in this post how Redux can work with any type of app at all.

Redux's super power is that it makes sure that every state-change in your application is predictable and traceable.

> If your app's state is starting to get unwieldy and you're having trouble figuring out \*how\* your app got into a given state, Redux may be able to help!

It is comprised of 4 basic components:

1. A **store** where your application's state is kept
2. **Actions** which are simple JavaScript objects that represent state-changing events in your app. Actions say to the store, "hey, Store, _something happened_ and you might need to update the current state!"
3. A **dispatcher** which is used to submit those actions to the store
4. And a **reducer** which is a function used by the store to determine _how_ your application's state should change in response to a given action

The terminology may be unfamiliar, but conceptually it's really pretty simple! We have a single place to keep our state (the store), we have a way to indicate to the store that _something happened_ (actions), and we have a way to interpret those actions in order to decide if/how the state should change (the reducer).

If you've used Redux with React before, you may be surprised that we haven't mentioned anything about `connect`, `<Provider>`, `mapStateToProps` etc. That's because those are concepts from the `react-redux` library which provides helpers to integrate Redux with a React app. Redux works perfectly well without these helpers--in fact--we're about to build a simple application with Redux and we're not going to use React at all!

## A Minimal Redux App

We're going to build a "counter" application. It'll have 2 buttons (plus and minus) and, between the buttons, it will display the current value of the counter. It'll look something like this:

<Counter />

### Disclaimer

The _state_ that this app tracks is just a single number (the current count), and there are only two ways that the state can change (the plus button and the minus button). **We don't need Redux in this app**!

> Remember: if you're having trouble figuring out \*how\* your app got into a certain state, Redux can help by making sure that state-changes are predictable and traceable

We're using Redux in this app for illustrative purposes, but remember that adding a dependency or framework to your application almost always comes with a cost. In the case of Redux, we introduce some abstractions (e.g. actions, a store, a reducer) which are helpful in complex applications, but add unnecessary cognitive load in simpler projects like this one.

With that said, let's get started!

### The HTML

```html
<html>
  <head>
    <title>Redux Counter</title>
  </head>
  <body>
    <button id="subtractButton">-</button>
    <div id="counterDisplay">0</div>
    <button id="addButton">+</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/redux/4.0.0/redux.js"></script>
    <script>
      // here is where we'll use Redux to manage our state
    </script>
  </body>
</html>
```

There it is. It's beautiful. It's 2 buttons and a div. We've included Redux via a script tag, but we haven't done anything with it yet. Let's change that!

### State

We know that Redux is going to help us manage the _state_ of our app. But what _is_ an app's _state_ exactly?

Earlier, I referred to the state of the app as _the data behind the UI_; let's deconstruct that a little bit. In modern UI development, it is often convenient to think of your UI as _a function of your state_, which is to say: given some data (the current state), we should be able to produce a UI for that state. This is a really powerful concept that we won't get too deep into in this post, but suffice to say: we want to be able to determine what our UI looks like based purely on some set of data (the state). So, when we say that our state is _the data behind the UI_ we mean that the state is the information that determines how the UI looks at a given snapshot in time.

Exactly _how_ you want to represent your state is up to you; as long as it contains enough info in order to produce your UI, it'll work. In this case, we really only need to know one thing in order to render our UI: the current value of the counter. So, let's keep our state in an object like this:

```ts
// this is not actually code
// it's just an illustration of what our state will look like
{
  count: number
}
```

More complex applications would have much more complicated state-layouts, but this one is perfect for our little counter.

Now that we know what our state is going to look like, let's think about the different ways that it can change!

### The Reducer (aka `getNextState`) Part 1

In the Redux world, the reducer function has a very important job: take the current state of the app and an `action` and return the next state of the app. That's why I sometimes think of the reducer as the `getNextState` function.

```js
nextState = reduce(currentState, action)
```

Before we write that function, let's take a detour to talk about _actions_.

### Actions

Actions represent the fact that _something just happened_ in the app. Actions will used by the reducer in order decide what the next state of the app should be.

Before we get into the technical details of how we'll create our actions, let's think about the different ways that our state can change. Recalling the description of the app, we know that the counter should increment when the user clicks the plus button, and it should decrement when the user clicks the minus button. Pretty straight-forward!

Okay, now let's use what we know about our reducer in order to figure out what our actions should look like. We don't know _exactly_ how the reducer is going to work yet, but we know the inputs and outputs that we want, right?

The input is always `currentState` and an `action`, and the output is always `nextState`. So let's sketch out a few examples.

Let's say that we're starting fresh and the currentState is `{ count: 0 }`, and then the user clicks the plus button. Now, we know that the output (nextState) should be `{ count: 1 }`, so if we substitue those values into our reducer equation we get:

```js
{ count: 1 } = reduce({ count: 0 }, action)
```

Again, we haven't written the `reduce` function yet, but we know that whatever we pass in for `action` needs to be able to tell `reduce` to increment the count by 1.

So, how about `action = 'ADD'`?

That'll work! When we're writing the reducer function, we'll just say:

```js
if (action === 'ADD') {
  // increment the count
}
```

Let's put this into some real code:

```js
const ADD_ACTION = 'ADD'
const SUBTRACT_ACTION = 'SUBTRACT'
```

For our application, these simple actions will work just fine, but as an exercise let's explore how we might do things differently in a slightly-more-complex app.

#### ActionCreators

Let's say that somewhere down the line we wanted to add another button to our app that added 10 to our counter rather than just adding 1. How would we represent that functionality as an action?

Well, we could define another action `ADD_10_ACTION = 'ADD_10'` and then in our reducer we'd say:

```js
if (action === 'ADD_10') {
  // increment counter by 10
}
```

That would work, but now our reducer needs to add an extra `if` for every different amount that we want to add or subtract. This could quickly get out of hand as we add more buttons to the app. Instead, let's leverage the fact that actions are just plain old JavaScript values.

Rather than passing a string like `"ADD"` or `"ADD_10"`, let's pass an object that has the `type` of action and some extra data for the reducer to use.

```ts
// this is not actually code
// it's just an illustration of what our actions could look like
ADD_N_ACTION: { type: 'ADD', amount: number }
```

Now our reducer can be much simpler:

```js
if (action.type === 'ADD') {
  // increment counter by action.amount
}
```

Much better!

Now to put that into real code:

```js
const ADD_1_ACTION = { type: 'ADD', amount: 1 }
const ADD_10_ACTION = { type: 'ADD', amount: 10 }
const SUBTRACT_1_ACTION = { type: 'SUBTRACT', amount: 1 }
```

Hm. We simplified the reducer, but we still need to list out an action for every different amount that we want to add or subtract. What if we wrote some little helper functions to generate those actions for us?

```js
function createAddAction(amount) {
  return { type: 'ADD', amount: amount }
}

function createSubtractAction(amount) {
  return { type: 'SUBTRACT', amount: amount }
}
```

Beautiful! Now we can handle adding or subtracting _any_ amount without needing to manually add more actions or needing to update our reducer.

This pattern of creating helper-functions which generate actions is called the `actionCreator` pattern, and it's so helpful that it's often taught as the primary way to handle actions with Redux! But I want you to keep in mind that our first implementation--the one where our actions were just simple strings--would have worked just fine in this app. There's nothing Redux-specific about the code that we just added; indeed, we haven't even used the Redux library yet! We used our JavaScript skills to come up with a more scalable pattern that uses objects rather than strings and to build helper functions that make our lives easier.

This is going to be a theme throughout the blog post: most of the perceived "magic" around Redux is actually just handy patterns like this one that folks have devised in order to make their lives easier. Redux itself, isn't involved yet :)

Even though we don't need the `actionCreator` pattern for this app, let's use it anyway so that we're ready to adapt to future feature requirements.

Now that we've got our `actions`, let's actually write some real code for the reducer!

### The Reducer (aka `getNextState`) Part 2

We already speculated a little bit about how we might build our reducer, but now we're gonna do it for real!

I'll use a switch statement rather than `if/else`, but you can write yours however you want.

```html
<script>
  // action creators omitted for brevity

  const initialState = { count: 0 }

  function reduce(currentState, action) {
    // Redux asks us for the initial state
    // by passing in `undefined` as the currentState
    if (currentState === undefined) {
      return initialState
    }

    switch (action.type) {
      case 'ADD':
        return {
          count: currentState.count + action.amount,
        }
      case 'SUBTRACT':
        return {
          count: currentState.count - action.amount,
        }
      default:
        /*
        if the action.type was not ADD or SUBTRACT,
        we return the currentState unchanged
        */
        return currentState
    }
  }
</script>
```

This should be pretty straight-forward, but there are a few parts that might not be intuitive yet. Let's break it down.

#### Initial State

The trick here is that when Redux first initializes, it is going to call our reducer function with `undefined` as the `currentState` in order to figure out the first state of the app. So we handle that by saying "if currentState is undefined, pass back the initialState".

#### How Redux Detects a Change

The next part that might look a little funny is the return statement.

```js
return {
  count: currentState.count + action.amount,
}
```

Here, we're creating a new object with the updated `count` value and returning it. But wouldn't it have been simpler to do something like this:

```js
// this reducer is broken!
// read on to see why

function reduce(currentState, action) {
  switch (action.type) {
    case 'ADD':
      currentState.count += action.amount
    case 'SUBTRACT':
      currentState.count -= action.amount
    default:
    // don't change anything
  }

  return currentState
}
```

This reducer is much simpler, but it actually won't work! Indeed it takes the `currentState` and an `action` and returns the `nextState`, but Redux actually requires an extra hint from us in order to determine if the state actually changed or not. That hint is when we _return a new object_ rather than returning the same object that was passed in.

So, this works great:

```js
return { count: currentState.count + action.amount }
```

And this doesn't work at all:

```js
currentState.count++
return currentState
```

> Understanding this behavior is _crucial_ for anyone using Redux; it's a little bit tricky at first, but it's also what allows Redux to be so incredibly fast.

In order to grasp what's going on, we need to think about how Redux actually detects a change in our app's state. It works like this:

1. Redux takes note of the `currentState`
2. Redux calls our `reducer` in order to determine the `nextState`
3. Redux compares the old `currentState` with the new `nextState` and decides if something has changed

Step 3 is where we'll focus. Redux has a few options for how it could compare the old state to the new state. But keep in mind that `nextState` and `currentState` might be huge, complex objects which represent the entire state of a highly-interactive app. If Redux took the time to traverse the entire `currentState` and `nextState` objects in order to determine if _every single key_ and _every single value_ is exactly the same between both of them, it would take much too long in complicated apps. Instead, it uses a _referential comparison_ (e.g. `nextState !== currentState`) to see if the two values _refer_ to the same spot in memory.

This referential comparison is **super fast**, and it stays super fast even as your app gets more and more complex. Conversely, if Redux took the time to compare every single value in your state, it would get slower and slower as your app grew.

So, now that we know that Redux uses a `referential comparison` in order to detect changes. It's clear why we always return a new object when the state changes, and we return the old object when the state didn't change.

Have another look at the reducer:

```js
switch (action.type) {
  case 'ADD':
    // returns a new object
    return {
      count: currentState.count + action.amount, // overwrite count
    }
  case 'SUBTRACT':
    // returns a new object
    return {
      count: currentState.count - action.amount, // overwrite count
    }
  default:
    // return the old currentState as-is, there's no change
    return currentState
}
```

The takeaway:

> Always return a new object from your reducer in order to hint to Redux that the state has changed

#### Future Proofing

Before we move on, let's make one more change to our reducer so that we're ready to handle new features in the future.

Let's say that as time goes on we decide to add a new feature to our counter that lets users change the theme color from light-mode to dark-mode. Now we've got some more state to track. Rather than just `{ count: number }` we have `{ count: number, theme: 'dark' | 'light' }`. Let's imagine that we've already written a neat actionCreator to handle this feature, and we just need to update the reducer.

```js
const initialState = { count: 0, theme: 'light' }

function reduce(currentState, action) {
  if (currentState === undefined) {
    return initialState
  }

  switch (action.type) {
    case 'ADD':
      return {
        theme: currentState.theme,
        count: currentState.count + action.amount,
      }
    case 'SUBTRACT':
      return {
        theme: currentState.theme,
        count: currentState.count - action.amount,
      }
    case 'CHANGE_THEME':
      return {
        count: currentState.count,
        theme: action.newTheme,
      }
    default:
      return currentState
  }
}
```

Not so bad. But notice that we had to add an extra line to each of the different `case`s. When we update the count, we need to make sure that we pass back the current theme unchanged. Likewise, when we update the theme, we need to make sure that we pass back the current count unchanged. That's because Redux expects us to return the _entire_ nextState, not just a little piece of it.

Okay, but what happens when the app gets even more complex and we need to keep track of even more state? Are we going to need to add an extra line to every `case` in our reducer for every new state that we want to track? That would be a pain.

Instead, let's make use of a neat JavaScript feature which allows us to clone _all of the keys_ from one object into another. This way, in each of our `case`s we can say: clone all of the current values, and then change this one thing. Here's what that might look like:

```js
const initialState = { count: 0, theme: 'light' }

function reduce(currentState, action) {
  if (currentState === undefined) {
    return initialState
  }

  switch (action.type) {
    case 'ADD':
      return {
        // clone currentState
        ...currentState,
        // overwrite the count with the new value
        count: currentState.count + action.amount,
      }
    case 'SUBTRACT':
      return {
        // clone currentState
        ...currentState,
        // overwrite the count with the new value
        count: currentState.count - action.amount,
      }
    case 'CHANGE_THEME':
      return {
        // clone currentState
        ...currentState,
        // overwrite the theme with the new value
        theme: action.newTheme,
      }
    default:
      return currentState
  }
}
```

Now we're cooking! Next time we want to add some more state, all of our previous `case`s will automatically handle cloning the value so that we don't have to manually add code to each one.

### Store

Now that we have our reducer, we'll construct our store. We'll use Redux's `createStore` method and we'll pass it the `reduce` function that we created in the last step. Note that this is the first time we've actually used the Redux library at all; everything else that we've done has just been plain old objects and functions!

```html
<script>
  // ... actions and reducer omitted for brevity

  const store = Redux.createStore(reduce)
</script>
```

Awesome! At this point we've got a fancy new Redux store complete with a reducer that can handle `ADD`s and `SUBTRACT`s. The next step is to be able to dispatch those actions to the store whenever the user clicks one of our buttons.

### Dispatch

```html
<script>
  // ... actions and reducer omitted for brevity

  const store = Redux.createStore(reduce)

  document.getElementById('addButton').onclick = () => {
    // we'll create an ADD_1 action using our actionCreator
    // createAddAction(1) returns { type: "ADD", amount: 1 }
    const ADD_1_ACTION = createAddAction(1)

    // then dispatch it to the store
    store.dispatch(ADD_1_ACTION)
  }

  document.getElementById('subtractButton').onclick = () => {
    const SUBTRACT_1_ACTION = createSubtractAction(1)
    store.dispatch(SUBTRACT_1_ACTION)
  }
</script>
```

We're using the `dispatch` method that's exposed by the store in order to indicate that an action has occurred. Behind the scenes, the store will invoke our reducer function and determine the next state of the application, then it will broadcast a message out to any subscribers to let them know that the state has changed.

Let's take a moment to recap what we've done so far.

- We defined the shape of the _state_ of our app: it looked like this `{ count: number }`
- We defined 2 _action-creators_, which create actions for us. The actions themselves were just simple objects like this `{ type: "ADD", amount: 1 }`
- We defined our _reducer_, which is a function that handles the operation: `currentState + action = nextState`
- We used `Redux` to create a `store` and told that store that it should use our reducer function to figure out _how_ to change our app's state
- We defined click-handlers for our buttons which use the store's `dispatch` function to send `ADD_ACTION`s and `SUBTRACT_ACTION`s to the store; then we used plain old JavaScript to attach those handlers to our UI elements

Now, when we click those buttons, data is flowing through our app!

1. We click a button
2. That dispatches an action to the store
3. The store uses the `reducer` to determine the next state
4. The store broadcasts that the state changed

All that's left to do is to subscribe to those changes and to update our on-screen counter!

### Subscribing to changes

We'll use the `subscribe` function that's exposed by the `store` in order to listen for any changes to our app's state.

```html
<script>
  // ... actions, reducer, store-creation, and action-dispatching omitted for brevity

  store.subscribe(() => {
    // get the state
    const stateSnapshot = store.getState()

    console.log('state changed', stateSnapshot)

    // use plain old JavaScript to update our UI
    document.getElementById('counterDisplay').innerText = stateSnapshot.counter
  })
</script>
```

And we're done! [Here's a link to the full code](https://gist.github.com/tripphamm/f340d92dec153f4ca5f2a31a58be9ce4).

## Wrap Up

We've just written a minimal, but fully-functional Redux application. We've seen how "actions" are just simple objects, the reducer is just a plain function, and that the Redux-specific code really just boils down to:

1. `createStore` - to create the store
2. `store.dispatch` - to dispatch an action
3. `store.subscribe` - to listen for updates to the state

Now that we've covered the core functionality of Redux, we can look at [how it integrates with a framework like React](/react-redux).
